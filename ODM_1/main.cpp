#include <vector>
#include <windows.h>

#include <iostream>

using namespace std;

/*Даны 2 множества, выполнить операции над ними: объединение, пересечение, разность , симметрическую разность, декартово произведение, дополнение.
*/


//Функция объединения двух множеств А и В
void objed(vector<int> A, vector<int> B,vector<int> C) {  //вводимые данные функции - два множества,над которыми требуется произвести операцию, и третье - результат операции

    for (int i = 0; i < A.size(); i++) { //используем цикл для добавления элементов первого множества А в множество C
        //int buffer = A[i]; // buffer - элемент множества A
        C.push_back(A[i]); //Вводим в результирующий массив С элементы множества А
    }
    for (int i = 0; i < B.size(); i++) { //используем цикл для ввода элементов второго множества В в множество C
        C.push_back(B[i]); //Вводим в результирующий массив С элементы множества B
    }
    for (int i = 0; i < C.size(); i++) { // 2 цикла для удаления повторяющихся элементов в мультимножестве C
        for (int j = 0; j < C.size(); j++) {   //Мы берём один элемент и прогоняем весь массив в поиске одинаковых элементов
            if (C[i] == C[j] && i != j) C.erase(C.begin() + j); // Удаление повторяющихся элемeнтов множества С
        }
    }
    for (int i = 0; i < C.size(); i++) {
        cout << C[i] << " ";                     //вывод конечного результата
    }
}


//функция пересечения двух множеств А и В
void peres(vector<int> A, vector<int> B,vector<int> D) {
    for (int i = 0; i < A.size(); i++) {     //берём один элемент множества А
        for (int j = 0; j < B.size(); j++) {  //и сравниваем его с каждым элементом из множества B
            if (A[i] == B[j]) {              //Если в обеих множествах содержаться
                D.push_back(A[i]);               //одинаковые элементы то мы их добавляем
                break;                                          //в результирующее множество.
            }
        }

    }

    for (int i = 0; i < D.size(); i++) {
        cout << D[i] << " ";               //Вывод множества D
    }
}
  //разность двух множеств
void raznost(vector<int> A, vector<int> B, vector<int> E) {
    for (int i = 0; i < A.size(); i++) {  // Берём элемент из множества А
        for (int j = 0; j < B.size(); j++) {  //Последовательно сравниваем его с элементами из B
            if(A[i] != B[j] && (j+1 != B.size()))continue;
            if(A[i] != B[j] && (j+1 == B.size()))E.push_back(A[i]);
            if(A[i] == B[j])break;
        }
    }
    for (int i = 0; i < E.size(); i++) {
        cout << E[i] << " ";               //Вывод множества E
    }
}
 //симметрическая разность
void simm_raznost(vector<int> A, vector<int> B, vector<int> F) {
    for (int i = 0; i < A.size(); i++) {  // Берём элемент из множества А
        for (int j = 0; j < B.size(); j++) {  //Последовательно сравниваем его с элементами из B
            if(A[i] != B[j] && (j+1 != B.size()))continue;
            if(A[i] != B[j] && (j+1 == B.size()))F.push_back(A[i]);
            if(A[i] == B[j])break;
        }
    }
    for (int i = 0; i < B.size(); i++) {  // Берём элемент из множества А
        for (int j = 0; j < A.size(); j++) {  //Последовательно сравниваем его с элементами из B
            if(B[i] != A[j] && (j+1 != A.size()))continue;
            if(B[i] != A[j] && (j+1 == A.size()))F.push_back(B[i]);
            if(B[i] == A[j])break;
        }
    }
    for (int i = 0; i < F.size(); i++) {
        cout << F[i] << " ";               //Вывод множества F
    }
};
// декартово произведение
void dek_proizv(vector<int> A, vector<int> B, vector<int> G) {
    for (int i = 0; i < A.size(); i++) {  // Берем один элемент из множества А
        for (int j = 0; j < B.size(); j++) { // Берем один элемент из множества B
            G.push_back(A[i]);   // добавления элемента во множество G из множества А
            G.push_back(B[j]);    // добавления элемента во множество G из множества B
        }
    }
    for (int i = 0; i < G.size(); ++i) {
        cout << '<' << G[i] << ',' << G[i + 1] << '>';  //Вывод множество G
        i++;
    }
}

//Функция дополнения
void dop(vector<int> U, vector<int> A, vector<int> G) {
    G = U;
    for(int i = 0;i < A.size();i++){
        for(int j = 0;j < G.size();j++){
            if(A[i] == G[j]){G.erase(G.begin()+j);break;};
        }
    }
    for (int i = 0; i < G.size(); i++) {
        cout << G[i] << " ";               //Вывод множества G
    }
}

int main()
{
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);
    vector<int> U(31);  //создаётся универсум U - множество неотрицательных целых чисел до 30
    for (int i = 0; i < U.size(); i++) {
                U[i] = i;
    }
    vector<int> A,B; // множества A и B
    int key1;
    cout << "Введите 1 если хотите ввести элементы с помощью метода перечисления,2 - если с помощью высказывания.\n";
    cin >> key1;

    if(key1 == 1){
         cout << "Введите количестов элементов множества A и B:(размеры не должны превышать 10)\n";

         int a, b;  //переменные а и б есть мощности обоих массивов.
         cin >> a; //вводим мощность множества А [1,10]
         cin >> b;//вводим мощность множества В [1,10]

         cout << "\nВведите элементы первого множества(от 1 до 25):\n";
         for (int i = 0; i < a; i++) { //осуществляется ввод множества А
            int buffer; //создаём буффер что бы вводить данные с множества А
            cin >> buffer;// сначала записываем данные в буфферную переменную
            A.push_back(buffer);  //если число удовлетворяет условию,то добавляем элемент в множество
         }
         cout << "\nВведите элементы второго множества(от 1 до 25):\n";
         for (int i = 0; i < b; i++) { //осуществляется ввод множества А
            int buffer; //создаём буффер что бы вводить данные с множества А
            cin >> buffer;// сначала записываем данные в буфферную переменную
            B.push_back(buffer);  //если число удовлетворяет условию,то добавляем элемент в множество
         }
    }
    if(key1 == 2){
         cout << "Введите количестов элементов множества A и B:(размеры не должны превышать 10)\n";

         int a, b;  //переменные а и б есть мощности обоих массивов.
         cin >> a; //вводим мощность множества А [1,10]
         cin >> b;//вводим мощность множества В [1,10]
         cout << "высказывания, используемые для заполнения множеств:" << endl;
		cout << "для A: {x in N|x=k*2+2}, k изменяется от 1 до " << a << endl;
		cout << "для B: {y in N|y=k+5}, k изменяется от 1 до " << b << endl;
		for (int k = 1; k <= a; k++) //формирование множества А
		{
			int el = k * 2 + 2;
            A.push_back(el);
		}
		cout << "A={";
		for (size_t i = 0; i < A.size(); i++) //вывод множества А на экран
		{
			cout << A[i];
			if (i != A.size() - 1)
			{
				cout << ',';
			}
		}
		cout << '}' << endl;
		for (int r = 1; r <= b; r++) //формирование множества В
		{
			int el = r + 5;
            B.push_back(el);
		}
		cout << "B={";
		for (size_t i = 0; i < B.size(); i++) //вывод множества В на экран
		{
			cout << B[i];
			if (i != B.size() - 1)
			{
				cout << ',';
			}
		}
		cout << '}' << endl;
	}


    int n;  // n - Номер выбранного пункта в меню
    while (cout << "\nВыбор функции: \n 1)Объединение \n 2)Пересечение \n 3)Разность A от B  \n 4)Разность B от A \n 5)Симметрическая разность "
                   "\n 6)Дополнение от множества A \n 7)Дополнение от множества B \n 8)Декартово произведение AxB\n"
                   " 9)Декартово произведение BxA\n"
                   " 0) - Выход А\n"
                   && cin >> n) {
    switch (n)  //Меню для выбора функции
    {
        case 1:
        {
            cout << "\nОбъединение:\n";
            vector<int> D;  //создаётся множество D,которое будет результатом операции
            objed(A, B, D); //используется функция объединения множеств А и В
            break;
        }
        case 2:
        {
            vector<int> C;  //создаётся множество С,которое будет результатом операции
            cout << "\nПересечение:\n";
            peres(A, B, C);//используется функция пересечения множеств А и В
            break;
        }
        case 3:
        {
            vector<int> E; //создаётся множество Е,которое будет результатом операции
            cout << "\nРазность A от B\n";
            raznost(A, B, E);
            break;
        }
        case 4:
        {
            vector<int> F; //создаётся множество F,которое будет результатом операции
            cout << "\nРазность B от A\n";
            raznost(B, A, F);//используется функция разности множеств В и А
            break;
        }
        case 5:
        {
            cout << "\nСимметрическая разность:\n";
            vector<int> G; //создаётся множество G,которое будет результатом операции
            simm_raznost(A, B, G);//операция Симметрической разности
            break;
        }
        case 6:
        {
                cout << "\nДополнение от множества А:\n";
                vector<int> G;
                dop(U, A,G);   //операция дополнения на множество A
                break;
        }

        case 7:
        {
                cout << "\nДополнение от множества B:\n";
                vector<int> H;
                dop(U, B,H);   //операция дополнения на множество B
                break;
        }
        case 8:
        {
            cout << "\nДекартово произведение AxB:\n";
            vector<int> I;  //создаётся множество G,которое будет результатом операции
            dek_proizv(A, B, I);//операция Декартово произведение AxB
            break;
        }

        case 9:
        {
                cout << "\nДекартово произведение BxA:\n";
                vector<int> J;  //создаётся множество G,которое будет результатом операции
                dek_proizv(B, A, J);//операция Декартово произведение AxB
                break;
        }
        case 0:
        {
            exit(1);
        }
        default:{
            cout << "Такого пункта в меню нету.\n";
            break;
        }
        }
    }
}
